<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sysAI.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<section data-markdown data-separator-vertical="-VV-" data-separator="-s-">
					<script type="text/template">
<!-- .slide: id="intro_week_02"  -->
<!-- .slide: data-background="#ffffff" data-transition="zoom" -->
<p style="text-align: center;font-size: 15vmin">WEEK 02 <br> Python Packages and Modules</p>

-VV-

# Welcome to week 02 of the course

This week is all about integrating knowledge from the last two weeks and adding some advanced Python tools as well as Data science-focused modules in the Python eco-system specifically Numpy, Matplotlib and pandas. 

This week's last section is devoted to the assignment. I am still working on this section - will be uploaded shortly.  


-s-

<!-- .slide: id="Advanced Python"  -->
<!-- .slide: data-background="#ffffff" data-transition="zoom" -->
<p style="text-align: center;font-size: 15vmin">Advanced Python<br></p>

-VV-

# What are list comprehensions?

- List comprehension is a way to define and create lists building on existing lists.
- The syntax is elegant **`some_list = [expression for item in list]`** 
- However, while list comprehension can always be rewritten in a for loop, the reverse is not always true.
- Here is a [link](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions) If you want to know more 
- Consider the following:


```python
grid = []
for row in range(5):
    grid.append(list(range(5)))

```



```
[[0, 1, 2, 3, 4],
[0, 1, 2, 3, 4],
[0, 1, 2, 3, 4],
[0, 1, 2, 3, 4],
[0, 1, 2, 3, 4]]
```


- How would you rewrite this using list comprehension?
- Move to the next slide **after** you have an idea or even a solution.

-VV- 

# List comprehensions grid example 

- Using list comprehensions the code is more straightforward and also easy to extend. 



```python
grid =  [list(range(5)) for row in range(5)]
grid
```



```
[[0, 1, 2, 3, 4],
[0, 1, 2, 3, 4],
[0, 1, 2, 3, 4],
[0, 1, 2, 3, 4],
[0, 1, 2, 3, 4]]
```


- How would you rotate this grid using list comprehensions?
- Move to the next slide **after** you have an idea or even a solution.  

-VV-

# Nested List comprehensions rotated grid example 



```python
grid_rot90 = [[row[col] for row in grid] for col in range(5)]
grid_rot90
```



```
[[0, 0, 0, 0, 0],
[1, 1, 1, 1, 1],
[2, 2, 2, 2, 2],
[3, 3, 3, 3, 3],
[4, 4, 4, 4, 4]]
```


- How would you create the multiplication matrix using list comprehensions?
- Move to the next slide **after** you have an idea or even a solution  

-VV-

# multiplication matrix example 



```python
prod_matrix = [[x*y for x in range(1,11)] for y in range(1,11)]
prod_matrix
```



```
[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
[2, 4, 6, 8, 10, 12, 14, 16, 18, 20],
[3, 6, 9, 12, 15, 18, 21, 24, 27, 30],
[4, 8, 12, 16, 20, 24, 28, 32, 36, 40],
[5, 10, 15, 20, 25, 30, 35, 40, 45, 50],
[6, 12, 18, 24, 30, 36, 42, 48, 54, 60],
[7, 14, 21, 28, 35, 42, 49, 56, 63, 70],
[8, 16, 24, 32, 40, 48, 56, 64, 72, 80],
[9, 18, 27, 36, 45, 54, 63, 72, 81, 90],
[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]]
```


- Now a simple one: 
- given a sequence of 1-20 squared 
- Create two lists one with even and one with odds numbers
- Move to the next slide **after** you have an idea or better yet a solution  

-VV-

# Adding conditionals example 


```python
even_squares = [x**2 for x in range(1,21) if x**2%2==0]
odd_squares = [x**2 for x in range(1,21) if x**2%2!=0]
print(even_squares)
print(odd_squares)
```
```
[4, 16, 36, 64, 100, 144, 196, 256, 324, 400]
[1, 9, 25, 49, 81, 121, 169, 225, 289, 361]
```

-VV-

# map function

- The map function allows you to "map" a function to an iterable object. 
- in other words, we call the same function for every item in an iterable, such as a list. 
- For example, the function below is used to convert numeric age to a categorical age_group?


```python
def age_group(age):
    if age<=11:
        return 'children'
    elif age<=21:
        return 'teens'
    elif age<=65:
        return 'adults'
    else: 
        return 'elderly'
print(list(map(age_group,  list(range(1,90,3)))))

```
```
['children', 'children', 'children', 'children', 'teens', 'teens', 'teens', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'elderly', 'elderly', 'elderly', 'elderly', 'elderly', 'elderly', 'elderly', 'elderly']
```

- Can you write this in one using the ternary form?

-VV-

# Same functionality oneliner




```python
def age2group(age):
    return 'children' if age<=11 else 'teens' if age<=21 else 'adults' if age<=65 else 'elderly'
age_group = list(map(age2group,  list(range(1,90,3))))
print(age_group)
```
```
['children', 'children', 'children', 'children', 'teens', 'teens', 'teens', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'elderly', 'elderly', 'elderly', 'elderly', 'elderly', 'elderly', 'elderly', 'elderly']
```

-VV-

# what about multiple iterables?

- Map() can accept more than one iterable. 
- However, the iterables should be the same length
- If they are not, the shortest iterable will terminate the function



```python
def list2grid(s,e):
    return list(range(s,e))
grid = list(map(list2grid,  list(range(1,10)),list(range(2,30,3))))
grid
```



```
[[1],
[2, 3, 4],
[3, 4, 5, 6, 7],
[4, 5, 6, 7, 8, 9, 10],
[5, 6, 7, 8, 9, 10, 11, 12, 13],
[6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
[7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
[8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22],
[9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]]
```


-VV-

# filter function

- The filter function creates an iterator containing only items for which a function(item) is true. 
- In other words, similar to map() you combine a function with a list.
- The list is then filtered returning only **True** results.
- Here is a [link](https://docs.python.org/3/library/functions.html#filter) If you want to know more 


```python
def is_children(age_group):
    return age_group == 'children'
print(list(filter(is_children, age_group)))
```
```
['children', 'children', 'children', 'children']
```

-VV-

# What are Lambda Expressions?

- A lambda function is used for creating small, one-time, anonymous function object in Python. 
- The syntax is simple: **`lambda argument: expression`**
- Because a lambda function is an expression, it can be named. 
- Multi-arguments are expressed by separating arguments with a comma (,)
- Lambda expressions are rarely named - these are just to make a point
- Here is a [link](https://docs.python.org/3/tutorial/controlflow.html?highlight=lambda#lambda-expressions) If you want to know more 


```python
square = lambda x: x**2
product = lambda x,y: x*y
power = lambda x,y: x**y
```

-VV-

# So when would we use Lambdas?
- You guessed it. They are used with map and filter to simplify our code and make it more human-readable 

-VV-

# Using if else in Lambda function

- Using if-else in lambda function is little tricky, the syntax is as follows 
- if you shouted Ternary Operators pat yourself on the back

```python
lambda <arguments> : <Value if True> if <condition> else <Value if False>
```



```python
age2group = lambda age: 'children' if age<=11 else 'teens' if age<=21 else 'adults' if age<=65 else 'elderly'
print(list(map(age2group,  list(range(1,30,1)))))

```
```
['children', 'children', 'children', 'children', 'children', 'children', 'children', 'children', 'children', 'children', 'children', 'teens', 'teens', 'teens', 'teens', 'teens', 'teens', 'teens', 'teens', 'teens', 'teens', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults', 'adults']
```

-VV-

# As part of your home assignment 

- Create a lambda function that gets a list of numbers (can be either ints or floats) and return the sign of the number 
- We will go over several solutions for this in the hands-on sess

-VV-

# Creating bollean values using conditional lambda 


```python
is_children = lambda age: age<=11 
print(list(map(age2group,filter(is_children, list(range(5,30,1))))))
```
```
['children', 'children', 'children', 'children', 'children', 'children', 'children']
```

-VV-

# Zip function 

- The zip() function returns an iterator of tuples based on the iterable objects.
- Combining it with all we learned so far is a powerful tool 
- Here is a [link](https://docs.python.org/3/library/functions.html#zip) If you want to know more 


```python
num_list = list(range(1,7))
str_list  = list('string')
result = zip(num_list, str_list)
print(list(map(lambda a: str(a[0])+a[1], result)))
```
```
['1s', '2t', '3r', '4i', '5n', '6g']
```

-VV-

# Summary 

In this section we covered: 
- list comprehensions 
    - what they are, 
    - why they are useful 
    - how to use them
- We also covered map,filter and zip 
- And last but not least we looked at Lambda functions


-s-

<!-- .slide: id="Advanced Python"  -->
<!-- .slide: data-background="#ffffff" data-transition="zoom" -->
<p style="text-align: center;font-size: 15vmin">Jupyter magic commands<br></p>

-VV-

# Jupyter notebook 

- Magic commands are enhancements created for the interactive Python project which Jupyter notebook can be viewed as a web evolution of 
- Magic commands are designed to simplify everyday tasks in the standard data analysis workflow
- There are two types of Magic commands: 
    - Line magics, which are denoted by a single % prefix and operate on a single line of input, 
    - Cell magics, which are denoted by a double %% prefix and operate on multiple lines of input. 
- For a full list of magic commands press [here](https://ipython.readthedocs.io/en/stable/interactive/magics.html#line-magics)
- Here we will explore some of the most useful ones 

-VV-

# %time and %%time 

- When developing a pipeline, it is useful to know how much time a specific function needs 
- Time and its variations will do precisely that 
- To measure one line of code, we will use %time
- To measure a cell, we will use %%time


```python
%time print(list(map(age2group,filter(is_children, list(range(5,5000,1))))))
```
```
['children', 'children', 'children', 'children', 'children', 'children', 'children']
CPU times: user 849 µs, sys: 0 ns, total: 849 µs
Wall time: 754 µs
```

```python
%%time
even_squares = [x**2 for x in range(1,int(1e5)) if x**2%2==0]
odd_squares = [x**2 for x in range(1,int(1e5)) if x**2%2!=0]
```

-VV-

#  %timeit  and %%timeit 

- %timeit will measure multiple iterations of the same line and show some stats on them
- %%timeit will do the same for the cell


```python
%timeit even_squares = [x**2 for x in range(1,int(1e5)) if x**2%2==0]
```
```
44.4 ms ± 259 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
```


```python
%%timeit
even_squares = [x**2 for x in range(1,int(1e5)) if x**2%2==0]
odd_squares = [x**2 for x in range(1,int(1e5)) if x**2%2!=0]
```
```
88.5 ms ± 543 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
```

-VV-

# %load_ext autoreload

- This magic command is crucial for almost any actual work using Jupyter (except tutorials :)
- The  autoreload extension tracks any changes in your imports and will *auto* *reload* them to your scope 
- We will cover this in the next section when we explore how to use modules 
- But by running this, we allow any imported file to be updated 



```python
%load_ext autoreload
%autoreload 2
```

-VV-

#  %system

- If you want access to the shell, this magic command will do it.


```python
%system date +%s%N
```



```
['1591574785834787111']
```


- However, using exclamation mark (!) is even more useful  


```python
date = !date +%s%N
date
```



```
['1591574846881075689']
```


-VV-

# %whos

- This magic command plots a list of variables in your environment. 
- Their type and some additional info
- You can pass %whos a type to examine only variables of that type



```python
%whos int
```
```
Variable   Type    Data/Info
col        int     3
```

-VV-

# %who_ls 

- This magic command shows you the list of variables in your environment. 
- It also can use the type to subset the output


```python
%who_ls function
```



```
['age2group',
'is_children',
'list2grid',
'median',
'odd_prod',
'power',
'product',
'sign',
'square']
```


-VV-

# %xdel

- Delete a variable, clearing it from memory.



```python
%xdel even_squares
%whos list
```
```
Variable        Type    Data/Info
age_group       list    n=30
data            list    n=5
grid            list    n=9
grid_rot90      list    n=10
lst             list    n=6
num_list        list    n=6
prod_matrix     list    n=10
row             list    n=5
shark_letters   list    n=5
some_list       list    n=1
str_list        list    n=6
x               list    n=6
```

-VV-

#  %%svg

- render a cell using some external programing languaege in thsi case scalable vector graphics 
- Try this :)


```python
%%svg
<svg width="800" height="200">
  <g transform="translate(100,100)"> 
    <text id="TextElement" x="0" y="0" style="font-family:Verdana;font-size:24; visibility:hidden"> It's MAGIC!
      <set attributeName="visibility" attributeType="CSS" to="visible" begin="1s" dur="5s" fill="freeze" />
      <animateMotion path="M 0 0 L 100 100" begin="1s" dur="5s" fill="freeze" />
      <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="-30" to="0" begin="1s" dur="5s" fill="freeze" /> 
      <animateTransform attributeName="transform" attributeType="XML" type="scale" from="1" to="3" additive="sum" begin="1s" dur="5s" fill="freeze" /> 
    </text> 
  </g> 
  Sorry, your browser does not support inline SVG.
</svg>
```


-VV-

#  %%writefile Hello_world.py

- Write the contents of a cell to a file in the same folder 



```python
%%writefile Hello_world.py
print('Hello World')
Hello = 'World'
```

    Overwriting Hello_world.py


-VV-

#  %run Hello_world.py
- If we can write we can also run


```python
%run Hello_world.py
print(Hello)
```

    Hello World
    World


-VV-

# Summary 

- In this section we covered Jupyter magic commands
- For example we saw how we can use magic commands to enhance Jupyter as a framework
- We also saw that we can inspect the notebooks scope using various whos commands 

-s-

<!-- .slide: id="Advanced Python"  -->
<!-- .slide: data-background="#ffffff" data-transition="zoom" -->
<p style="text-align: center;font-size: 15vmin">Modules and Packages<br></p>

-VV-

# Modules and Packages

- Python core language is compact. 
- This is an intentional design feature to maintain simplicity. 
- Much of the powerful functionality comes through external modules and packages.
- Here is a [link](https://docs.python.org/3/tutorial/modules.html#modules) If you want to know more 

-VV-

#  Module


- A module is simply a file with the .py extension, containing Python definitions, functions, and statements. 
- Modules are imported from other modules using the import command.
- The first time a module is loaded into a running Python script, it is initialized by executing the code in the module once.
- If we change the module, we need to reload it for these changes to take effect

-VV-

# Modules are useful becuase they:

1. Simplify your code by calling readable functions instead of multiple lines of code
2. Make it simpler to maintain, improve and collaborate 
3. Allow you to organize your code in different files (each a different module)
     

-VV-

#  Creating a Module

- In  normal coding classes, students usually start by creating a script file with a py ending that prints **"Hello World"**
- However, in the  Jupyter notebook realm, it is useful to start by simply creating a text file called my_module.py
- We will copy every helpful function into that file
- As long as it is in the same folder as your notebook you can simply *import* it 
- Let's test this 

-VV-

#  Using jupyter magic to write a our my_module.py

- So we can use magic to create this file. However, it might be useful to open it afterwards as a text file so we can update it with any other helpful function (as we will see in the next sections) 
- The current example should not be considered good practice, it is just to show some functionality that we can relate to  
- Interesting fact, single underscores are a Python naming convention indicating that  the object is meant for internal use
- We are using this here to make the functions stand out visually


```python
%%writefile my_module.py
_sum_sq = lambda data: sum(x ** 2 for x in data)
_sum = lambda data: sum(x for x in data)
_mean = lambda data: _sum(data)/float(len(data))
_sq_mean = lambda data: _sum_sq(data)/float(len(data)-1)
_var = lambda data: sum((x - _mean(data))**2/float(len(data)-1) for x in data)
```

    Overwriting my_module.py


-VV-

#  Using import to load my_module


- Now we can import this python file and all the lambda function we defined exist in our scope 


```python
import my_module 

print(my_module._var(list(range(3,20))))

```

    25.5


-VV-

#  Add Sample standard deviation to your_module

- The standard deviation of the sample mean is defined using the following formula 

$$ s = \sqrt{\frac{1}{N-1}\sum^n_{i=1} (x_i-\bar{x})^2} $$

- Try to implement your std function and place it into your module file
- Now see if it indeed reloads automagically 



```python
my_module._std(list(range(3,20)))
```




    5.049752469181039



-VV-

#  printing built-in modules

- Using the dir command we can see the different modules that compose a package
- but waht is a package? 



```python
import pathlib

print(dir(pathlib))
```

    ['EBADF', 'EINVAL', 'ELOOP', 'ENOENT', 'ENOTDIR', 'Path', 'PosixPath', 'PurePath', 'PurePosixPath', 'PureWindowsPath', 'S_ISBLK', 'S_ISCHR', 'S_ISDIR', 'S_ISFIFO', 'S_ISLNK', 'S_ISREG', 'S_ISSOCK', 'Sequence', 'WindowsPath', '_Accessor', '_Flavour', '_IGNORED_ERROS', '_IGNORED_WINERRORS', '_NormalAccessor', '_PathParents', '_PosixFlavour', '_PreciseSelector', '_RecursiveWildcardSelector', '_Selector', '_TerminatingSelector', '_WildcardSelector', '_WindowsFlavour', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_ignore_error', '_is_wildcard_pattern', '_make_selector', '_normal_accessor', '_posix_flavour', '_windows_flavour', 'attrgetter', 'fnmatch', 'functools', 'io', 'nt', 'ntpath', 'os', 'posixpath', 're', 'supports_symlinks', 'sys', 'urlquote_from_bytes']


-VV-

# How to define a package

- Packages are a way of structuring Python’s module namespace by using “dotted module names”
- They are simple directories, containing several python scripts.
- Defining a package in Python requires a uniqe folder and a special file called `__init__.py`
- For now this file can be empty 
- Here is a [link](https://docs.python.org/3/tutorial/modules.html#packages) If you want to know more 

-VV-

# make a directory called my_package

- We will use Jupyter magic to change the cell to `%%bash`
- And use what we learned in week_00 to create the following structure 



```bash
%%bash
mkdir -p my_package
touch my_package/__init__.py
cp my_module.py my_package/my_stats.py

```

-VV-

# Now we can import our package 

- Using the from notation we import the new my_stats module to our scope 



```python
from my_package import my_stats

my_stats._std(list(range(3,20)))
```




    5.049752469181039



-VV-

# Summary 
- In this section we learned about modules and packages
- We learned how to create and load our own module
- We also learned how to define a package


-s-

<!-- .slide: id="Advanced Python"  -->
<!-- .slide: data-background="#ffffff" data-transition="zoom" -->
<p style="text-align: center;font-size: 15vmin">Anaconda<br></p>

-VV-

-VV-

# Installing anaconda on your home folder 

- One thing we ultimately want is having full control over the environment 
- The following is true to your local computer as well as the cluster 
- Anaconda gives us this power exactly 
- Installing it in your home folder on the cluster requires an **SSH terminal**
- So open one from your computer 

-VV-

# Installing a local varsion of anaconda 

- We are going to create a folder named install 
- Download anaconda into it using `wget`
- Install anaconda locally using bash 
- Create a unique environment 
- Register it as a Jupyter kernel and restart our notebook to see if it worked 

-VV-

# Download and install local anaconda 
<h2 style="background-color:red;color:white;padding:2%;">USING SSH TERMINAL ON YOUR COMPUTER.</h2>

- This step will take some time 

```bash
mkdir install && cd install
wget https://repo.anaconda.com/archive/Anaconda3-2020.02-Linux-x86_64.sh
bash ./Anaconda3-2020.02-Linux-x86_64.sh
```

-VV-

# create new anaconda kernel enviorment 
<h2 style="background-color:red;color:white;padding:2%;">USING SSH TERMINAL ON YOUR COMPUTER.</h2>


- Create a new anaconda kernel enviorment 

```bash
. ~/.bashrc # source bashrc
cd ~ && conda init
conda create --name sys2020 python=3.8.3 
conda activate sys2020
conda install ipykernel # needed in order to register the new enviorment 
```

-VV-

# register  to jupyter
<h2 style="background-color:red;color:white;padding:2%;">USING SSH TERMINAL ON YOUR COMPUTER.</h2>

- Register our new environment to Jupyter 
- To make it accessible, we need to restart the Jupyter notebook server



```python
python -m ipykernel install --user --name sys2020 --display-name "Python (sys2020)"
```

-VV-

# I think this is the login .profile that is sourced in the jupyter server
<h2 style="background-color:red;color:white;padding:2%;">IN SSH TERMINAL ON YOUR COMPUTER.</h2>

- We could append the following to a .profile file in your home directory 
- This line should source the global anaconda settings on each login to the notebook server 

```bash
echo "if [ -f ~/opt/conda/etc/profile.d/conda.sh ]; then" >> ~/.profile 
echo ". /opt/conda/etc/profile.d/conda.sh # --> source global conda.sh, if present." >> ~/.profile
echo "fi">> ~/.profile
```

-VV-

# restart the jupyter notebook server 


- To make our environment accessible, we need to restart the Jupyter notebook server 
- You do this by pressing on the control panel button in the top right and stoping your server 
- If you want to remove this kernel (after the course has ended), you can use the following command 
- And then delete the actual environment 


```python
jupyter kernelspec remove sys2020
rm -rf rm -rf ~/anaconda3/envs/sys2020
```

-VV-

# Important 
- On the GWDG cluster, this isn't necessarily the best approach 
- Therefore, after the course (or during it if you plan to start doing some work) I suggest you contact the IT group to make sure there isn't a better way 
- TBH it works, but I would have prefered working with a global anaconda using linux modules 

-VV-

# now we can install some essential packages we will use this week  
<h2 style="background-color:red;color:white;padding:2%;">IN SSH TERMINAL ON YOUR COMPUTER.</h2>

- We are going to install some more packages during the course 
- Most of you should have used all of these is some capacity or another 
- Therefore, I will allow myself to use Matplotlib to explain NumPy arrays 
- During this course, we will dive into the depth of Matplotlib, understand its benefits 
- And probably stop using it :)


```bash
conda install numpy matplotlib pandas 
```

-VV-

# requirements. txt

- Last week we discussed the importance of tracking the software you use to allow you and other colleagues to retrace your steps without dealing with technical difficulties due to different versions 
- Anaconda environments were designed specifically to deal with this challenge 
- The list command will export the current dependencies and their versions
- The conda create --name <env_name> --file <.txt file> will create the exact enviorment 



```python
! conda list -e > requirements.txt 
```

-VV-

# Summary 
- In this section we covered how to use Anaconda on the cluster
- We learned how to install it in our home directory using ssh
- We also learned how to create project specific enviorment
- Finally we installed some basic data science packages
-s-

<!-- .slide: id="Advanced Python"  -->
<!-- .slide: data-background="#ffffff" data-transition="zoom" -->
<p style="text-align: center;font-size: 15vmin">Numpy Basics<br></p>



-VV-

# Numpy Basics

- NumPy is **THE** numeric library for python.
- Almost all the packages we will use from now on will rely on NumPy on some way or another.
- It is also much faster and efficient than standard Python packages 
- NumPy is even more convenient. You get a lot of vector and matrix operations for free, which sometimes allow one to avoid unnecessary work. And they are also efficiently implemented.
- We won't cover all of Numpy functions and capabilities, but instead, we will focus on using vectors and arrays (politely ignoring matrix). 
- We will also cover some of the primary functions 
- But start by importing it to make sure it is loaded 


```python
import numpy as np
```

-VV-

# Numpy Arrays

- NumPy’s main data structure is the multidimensional array.
- Numpy arrays essentially come in two flavors: vectors and matrices. 
- Vectors are strictly 1-d arrays and matrices are at least 1-d (but with thickness of 1).

-VV-

# Creating 1d vectors and Arrays

- There are many ways of creating vectors 
- The simplest would be to use the range generator 
- Importantly, a vector has no thickness
- T = transpose (i.e. fliping the array over its diagonal)



```python
vector_row = np.array(range(1,11))
array_1d_column = np.array([range(1,11)])
array_1d_row = np.array([range(1,11)]).T

print(vector_row.shape)
print(array_1d_column.shape)
print(array_1d_row.shape)

```

    (10,)
    (1, 10)
    (10, 1)


-VV-

# Creating 1d vectors and Arrays from lists 

- There are many more ways of creating arrays 


```python
vector_row = np.array([1]*10)
array_2d = np.array([[1]*10]*10)
array_3d_wide = np.array([[[0.5]*3]*200]*100)
array_3d_tall = np.array([[[0.5]*3]*100]*200)
print(array_3d_wide.shape)
print(array_3d_tall.shape)
```

    (100, 200, 3)
    (200, 100, 3)


-VV-

# Creating 1d vectors and Arrays from lists 

- Height, width, depth = array_3d.shape
- Note, however, that ndarray has matrix coordinates (i,j), which are opposite to image coordinates (x,y).
- y, x, z = array_3d.shape
- let's visualize this 



```python
from matplotlib import pyplot as plt 
# we import matplotlib module pyplot and name it plt
fig, (ax1, ax2) = plt.subplots(1, 2)
# we create a figure containing two side by side plots
ax1.imshow(array_3d_wide)
ax2.imshow(array_3d_tall)
# we use the function imshow to visualize these 3d matrices as images 

```




    <matplotlib.image.AxesImage at 0x2aabd86dee50>




![png](output_108_1.png)


-VV-

# Creating 1d vectors using numpy Built-in Methods

- linspace() creates linearly spaced values 
- logspace() creates log10 spaced values 
- arange() is similar to range (i.e. Array of values from to with steps) 




```python
vector_linspaced = np.linspace(0,50,6)
vector_logspace = np.logspace(0,5,6)
vector_step = np.arange(0,50,10) 
print(vector_linspaced)
print(vector_logspace)
print(vector_step)


```

    [ 0. 10. 20. 30. 40. 50.]
    [1.e+00 1.e+01 1.e+02 1.e+03 1.e+04 1.e+05]
    [ 0 10 20 30 40]


-VV-

# Let's manipulate depth  

- We will change the 2nd depth dimension (let's call it a slice) to 1 in the array_3d_wide
- And changing the 3rd slice to 1 in the array_3d_tall array we can see differences between them not only in shape but also in the depth 
- This is important - if this isn't clear please let me know 


```python
from matplotlib import pyplot as plt 
# we import matplotlib module pyplot and name it plt
array_3d_wide[:,:,1] = 1
array_3d_tall[:,:,2] = 1
fig, (ax1, ax2) = plt.subplots(1, 2)
# we create a figure containing two side by side plots
ax1.imshow(array_3d_wide)
ax2.imshow(array_3d_tall)
# we use the function imshow to visualize these 3d matrices as images 

```




-VV-

# Creating Arrays using numpy Built-in Methods

- Built-in methods require tuple or list to create >=2d arrays
- We can create arrays of full of zeros 
- And they can have predefined data types (which means we can sacrifice some accuracy in favour of memory 
- This process is called to preallocate a matrix 



```python
zeros_vector = np.zeros(10)
zeros_2d_array = np.zeros((10,10))
zeros_3d__int8_array = np.zeros((10,10,10),dtype="int8")
zeros_3d_float64_array = np.zeros([10,10,10],dtype="float64")
# we can go on and on 
print(zeros_3d__int8_array.dtype)
print(zeros_3d_float64_array.dtype)

```

    int8
    float64


-VV-

# Creating Arrays using numpy Built-in Methods

- We can also create ones, identity matrix (i.e. ones in the lead diagonal)
- And even with predefined values using full



```python
ones_3d_int8_array = np.ones([10,10,3])
eye_3d_bool_array = np.eye(10,dtype="b")
full_3d_array = np.full((10,10,3),156)
fig, (ax1, ax2, ax3) = plt.subplots(1, 3)
ones_3d_int8_array[:,3:-3,:] = 0
ones_3d_int8_array[3:-3,:,:] = 0
full_3d_array[2:,:5,:2] = 50
# we create a figure containing two side by side plots
ax1.imshow(eye_3d_bool_array)
ax2.imshow(ones_3d_int8_array)
ax3.imshow(full_3d_array)

```










-VV-
# Creating Arrays using numpy Built-in Methods

- And even arrays with various randome number generators (e.g. rand, randint, randn)



```python
from matplotlib import pyplot as plt
# we import matplotlib module pyplot and name it plt
uniform_noise = np.random.rand(10,10)#
normal_noise = np.random.randn(10,10)#
discrete_noise = np.random.randint(0,3,size=(10,10))#

# we can go on and on
fig, (ax1, ax2, ax3) = plt.subplots(1, 3)

ax1.imshow(uniform_noise)
ax2.imshow(normal_noise)
ax3.imshow(discrete_noise)
```

-VV-

# Inspecting array Properties

- In Numpy array have properties
- We already saw the shape property that returns a tuple describing the length of each dimension
- We also saw Numpy has many different data types
- The last property I want to cover is Size which simple returns the number of dimensions the array has




```python
arr = np.array((10,20,30))
print(arr.size)
```

-VV-

# Indexing in Numpy vectors

- Indexing in Numpy is far simpler than in multidimensional lists
- lets explore some things



```python
vector = np.array(range(1,11))# 10 rows
print(f'Vector = {vector}')
print(f'First element = {vector[0]}')
print(f'Last element = {vector[-1]}')
print(f'Middle elements = {vector[len(vector)//2-1:len(vector)//2+1]}')
print(f'All elements strating from 4 = {vector[4:]}')
print(f'last 4 elements = {vector[-4:]}')
print(f'Everything but last 4 elements = {vector[:-4]}')
```

-VV-

# Two-Dimensional Indexing and Slicing in Numpy arrays

- Indexing in Numpy is far simpler than in multidimensional lists
- lets explore some things



```python
array = np.array([range(1,11)]).T*np.array([range(1,15)])# element wise multiplication
print(f'Vector = {array}')
print(f'First element = {array[0,0]}')
print(f'Last element = {array[-1,-1]}')
print(f'Middle elements = {array[array.shape[0]//2-1:array.shape[0]//2+1,array.shape[1]//2-1:array.shape[1]//2+1]}')
print(f'All rows above the 4th row = {array[4:,:]}')
print(f'last 4 columns = {array[:,-4:]}')
print(f'Everything but last 4 elements = {array[:,:-4]}')
```

-VV-

# Statistics in Numpy arrays

- Numpy has some basic statistics functions
- We will go over them quickly



```python
array = np.array([range(1,11)]).T*np.array([range(1,11)])# element wise multiplication

fig, (ax1) = plt.subplots(1,1)

ax1.imshow(array)
print(np.sum(array,axis=0)) # sum over the x dimension
print(np.mean(array,axis=1)) # mean over the y dimension
print(np.min(array,axis=1)) # min over the y dimension
print(np.max(array,axis=0)) # max over the y dimension
print(np.var(array,axis=1)) # var over the y dimension
print(np.std(array,axis=0)) # var over the y dimension
ax1.imshow(np.corrcoef(array))

```

# Summary
- In this section, you discovered how to create and access data in NumPy arrays with Python.
- Specifically, you learned:
- How to create NumPy arrays.
- How to access data using Pythonic indexing and slicing.


-s-

<!-- .slide: id="Advanced Python"  -->
<!-- .slide: data-background="#ffffff" data-transition="zoom" -->
<p style="text-align: center;font-size: 15vmin">Pandas Basics<br></p>

-VV-


# Introduction to Pandas

If Numpy is the central library for scientific computing in Python and Matplotlib is the primer (and the most complete)
data visualization, then Pandas lives in the middle and also builds on both libraries to support data manipulation
fundamental analysis and feature exploration.

Pandas data structures were created to make data analysis simpler. However, using it at first may feel intimidating.

-VV-


# We start by importing pandas

- lets make sure pandas is working


```python
import pandas as pd
```

-VV-


# Let's import some data

- The data set we will be working with is the unrestricted HCP behavioural, neuronal and demographics measures across
1206 subjects.
- The dataset contains the HCP_raw (which ironicly is the processed summary table for the entire HCP study
- This week is not about the data properties but rather learning how to read the data and use pandas
- We start by locating the data-sets using the basic modules os and glob


```python
import os
import glob
filelist = glob.glob(os.path.join("learning/course_2020/data/*/*.csv"))
filelist
```

-VV-


# HCP_DataDictionary and HCP_raw

- The HCP_DataDictionary is a csv table describing all the columns representing unique features
- We will now read the HCP_DataDictionary using the pandas read_csv function


```python
df = pd.read_csv(filelist[1], encoding = "ISO-8859-1")
df.head()
```

-VV-


# DataDictionary number of categories

- Each column in this dataframe will return a pandas.Series data structure
- Access is simple we use the column header to select one series ds
- Series have several powerful functions amoung them the unique function that extracts only unique values
- Can you think of another way to get the unique values?
- If you said sets you can pat yourself on the shoulder

-VV-


# DataDictionary unique number of categories

- If we compare both approuches we can see that the set is not only faster but also far stabler


```python
%timeit df['category'].unique()
%timeit set(df['category'])
```

-VV-

# Back to the DataDictionary categories

- We can see that the dateset is rich in interesting categories
- What we want to view now is some summary for each category
- The count() function together with groupby will give you excatly that


```python
set(df['assessment'])
df.groupby('category').count()
```
-VV-

# subset

- In big data sets it is often common to examin only a subset of the data. 
- For example lets try to create a subset containing only data from the **"Emotion"** category
- To do that I will first use the dictionary dataset to identify all the **"Emotion"** column headers 
- Then we will use these headers to subset the actual dataset 


-VV-

# subset

- We are using logical expressions to identify any **row** in the hcp dictionary whose category is equal to Emotion
- We can use either key or dot notation to acheive this 


```python
# key notation is the same 
hfh_hcp = df["columnHeader"][df['category']=="Emotion"]
# as dot notation
hfh_hcp = df.columnHeader[df.category == 'Emotion']
hfh_hcp
```
-VV-

# subset

- Now I want to use these columnHeader to extract only those for quick data inspection
- Lets upload the first 100 rows
- Then create the subset



```python
df_hcp = pd.read_csv(filelist[0], encoding = "ISO-8859-1",nrows=100)
subset = df_hcp.loc[:, df_hcp.columns.isin(list(hfh_hcp))].copy()
```
-VV-

# subset

- lets use the describe function extract some basic statistics



```python
subset.head()
subset.describe()
```
-VV-

# subset

- The cross-correlation of the data suggests multicollinearity
- Next week we will explore this further
- For now, let's finish with this analysis and move the home assignment


```python
import matplotlib.pyplot as plt
fig, (ax1) = plt.subplots(1,1)
im = ax1.matshow(subset.corr())
fig.colorbar(im, ax=ax1);
```
-VV-

# Summary

- We only touched the surface of using pandas to explore a complex data set like this
- But we have an arsenal of tools to allow us to do so
- Next week we will finish going over the essential tools that allow basic exploration of data set
- We will also learn how to automate some of these steps
-s-

# Home assignment

- Create a notebook with your name under notebooks week_02
- In it using pandas import both the hcp data and the hcp dictionary
- Using the dictionary select one category and use its features to create a short report describing the different
relationship between the features
- You should have a minimal description of the category and the features it includes
-VV-
# Home assignment
- What are they trying to measure
- What is the association between them
- Next week we will explore various exploratory analysis methods to examine these relationships in-depth
- This assignment will take two-week so take your time


</script>
</section>
</div>
</div>

<script src="js/reveal.js"></script>
<script src="js/config.js"></script>
<script>
window.onload=function(){function a(a,b){var c=/^(?:file):/,d=new
XMLHttpRequest,e=0;d.onreadystatechange=function(){4==d.readyState&&(e=d.status),c.test(location.href)&&d.responseText&&(e=200),4==d.readyState&&200==e&&(a.outerHTML=d.responseText)};try{d.open("GET",b,!0),d.send()}catch(f){}}var
b,c=document.getElementsByTagName("*");for(b in
c)c[b].hasAttribute&&c[b].hasAttribute("data-include")&&a(c[b],c[b].getAttribute("data-include"))};
</script>	
</body>

</html>
